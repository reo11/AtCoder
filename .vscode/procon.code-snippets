{
	"for": {
		"scope": "python",
		"prefix": "for",
		"body": [
			"for i in range(n):"
		],
		"description": "for template"
	},
	"if": {
		"scope": "python",
		"prefix": "if",
		"body": [
			"if :",
			"\tpass",
			"else:",
			"\tpass"
		],
		"description": "if template"
	},
	"Yes/No": {
		"scope": "python",
		"prefix": "Yes",
		"body": [
			"print(['No', 'Yes'][x])"
		],
		"description": "Yes/No template"
	},
	"yes/no": {
		"scope": "python",
		"prefix": "yes",
		"body": [
			"print(['no', 'yes'][x])"
		],
		"description": "yes/no template"
	},
	"N": {
		"scope": "python",
		"prefix": "input",
		"body": [
			"int(input())"
		],
		"description": "n"
	},
	"A B C ...": {
		"scope": "python",
		"prefix": "input",
		"body": [
			"map(int, input().split())"
		],
		"description": "A B C ..."
	},
	"A_1 A_2 ... A_N": {
		"scope": "python",
		"prefix": "input",
		"body": [
			"list(map(int, input().split()))"
		],
		"description": "A_1 A_2 ... A_N"
	},
	"A_1, A_2, ... A_N": {
		"scope": "python",
		"prefix": "input",
		"body": [
			"[int(input()) for _ in range(n)]"
		],
		"description": "A_1, A_2, ... A_N"
	},
	"A_1 B_1, A_2 B_2, ... A_N B_N": {
		"scope": "python",
		"prefix": "input",
		"body": [
			"[list(map(int, input().split())) for _ in range(n)]"
		],
		"description": "A_1 B_1, A_2 B_2, ... A_N B_N"
	},
	"S_1 V_1, S_2 V_2, ... S_N V_N": {
		"scope": "python",
		"prefix": "input",
		"body": [
			"sv = [input().split() for _ in range(n)]",
			"sv = [(str(x[0]), int(x[1]))for x in sv]"
		],
		"description": "S_1 V_1, S_2 V_2, ... S_N V_N"
	},
	"e": {
		"scope": "python",
		"prefix": "input",
		"body": [
			"[[i for i in list(str(input()))] for i in range(h)]"
		],
		"description": "e .#.#.#"
	},
	"template": {
		"scope": "python",
		"prefix": "template, sys",
		"body": [
			"import sys",
			"input = sys.stdin.readline",
			"sys.setrecursionlimit(20000000)"
		],
		"description": "template"
	},
	"defaultdict": {
		"scope": "python",
		"prefix": "defaultdict, defa",
		"body": [
			"from collections import defaultdict",
			"d = defaultdict(int)"
		],
		"description": "defaultdict"
	},
	"iter": {
		"scope": "python",
		"prefix": "iter",
		"body": [
			"from itertools import permutations, combinations"
		],
		"description": "itertools"
	},
	"bit": {
		"scope": "python",
		"prefix": "bit",
		"body": [
			"for i in range(2 ** n):",
			"\tfor j in range(n):",
			"\t\tif ((i >> j) & 1):",
			"\t\t\tpass",
			"\t\telse:",
			"\t\t\tpass"
		],
		"description": "Bit全探索"
	},
	"union-find": {
		"scope": "python",
		"prefix": "union",
		"body": [
			"class UnionFind():",
			"    def __init__(self, n):",
			"        self.n = n",
			"        self.root = [-1]*(n+1)",
			"        self.rank = [0]*(n+1)",
			"",
			"    def Find_Root(self, x):",
			"        if(self.root[x] < 0):",
			"            return x",
			"        else:",
			"            self.root[x] = self.Find_Root(self.root[x])",
			"            return self.root[x]",
			"",
			"    def Unite(self, x, y):",
			"        x_root = self.Find_Root(x)",
			"        y_root = self.Find_Root(y)",
			"",
			"        if(x_root == y_root):",
			"            return",
			"        # 違う木に属していた場合rankを見てくっつける方を決める",
			"        if self.rank[x_root] >= self.rank[y_root]:",
			"            self.rank[x_root] += self.rank[y_root]",
			"            self.root[y_root] = x_root",
			"        else:",
			"            self.rank[y_root] += self.rank[x_root]",
			"            self.root[x_root] = y_root",
			"",
			"    # xとyが同じグループに属するか判断",
			"    def isSameGroup(self, x, y):",
			"        return self.Find_Root(x) == self.Find_Root(y)",
			"",
			"    # ノードxが属する木のサイズを返す",
			"    def Count(self, x):",
			"        return self.rank[self.Find_Root(x)]",
		],
		"description": "union-find tree"
	},
	"flt": {
		"scope": "python",
		"prefix": "flt",
		"body": [
			"class FLT:",
			"    #フェルマーの小定理",
			"    # a^(-1) = a^(m-2) mod p",
			"    def __init__(self, mod=10**9+7):",
			"        self.mod = mod",
			"",
			"    def rep_sqr(self, base, k):",
			"        if k == 0:",
			"            return 1",
			"        elif k % 2 == 0:",
			"            return (self.rep_sqr(base, k // 2) ** 2) % self.mod",
			"        else:",
			"            return (self.rep_sqr(base, k - 1) * base) % self.mod",
			"",
			"    def inv(self, a):",
			"        # 逆元を取る" ,
			"        return self.rep_sqr(a, self.mod-2)",
		],
		"description": "フェルマーの小定理"
	},
	"facts": {
		"scope": "python",
		"prefix": "fact",
		"body": [
			"from math import factorial",
			"",
			"class Facts():",
			"    # 階乗のメモ化",
			"    # 組み合わせ数、順列数の計算を高速に行う",
			"    def __init__(self, max_num=10**5, p=10**9 + 7):",
			"        self.p = p",
			"        self.max_num = max_num",
			"        self.fact = [1] * (self.max_num + 1)",
			"        for i in range(1, self.max_num + 1):",
			"            self.fact[i] = self.fact[i-1] * i",
			"            self.fact[i] %= self.p",
			"",
			"    def comb(self, n, k):",
			"        # nCk mod p を求める",
			"        if n < 0 or k < 0 or n < k:",
			"            return 0",
			"        if n == 0 or k == 0:",
			"            return 1",
			"        a = self.fact[n]",
			"        b = self.fact[k]",
			"        c = self.fact[n-k]",
			"        return (a*self.power_func(b, self.p-2) *",
			"                self.power_func(c, self.p-2)) % self.p",
			"",
			"    def perm(self, n, k):",
			"        # nPk mod p を求める",
			"        if n < 0 or k < 0 or n < k:",
			"            return 0",
			"        if n == 0 or k == 0:",
			"            return 1",
			"        a = self.fact[n]",
			"        b = self.fact[n-k]",
			"        return (a * self.power_func(b, self.p-2)) % self.p",
			"",
			"",
			"    def power_func(self, a, b):",
			"        # a^b mod p　を繰り返し二乗法で求める",
			"        if b == 0:",
			"            return 1",
			"        if b % 2 == 0:",
			"            d = self.power_func(a, b//2)",
			"            return d*d % self.p",
			"        if b % 2 == 1:",
			"            return (a*self.power_func(a, b-1)) % self.p",
		],
		"description": "階乗、組み合わせ、順列の計算を高速化"
	},
	"gcd": {
		"scope": "python",
		"prefix": "gcd",
		"body": [
			"from functools import reduce",
			"",
			"def gcd(a, b):",
			"    while b:",
			"        a, b = b, a % b",
			"    return a",
			"",
			"def lcm(x, y):",
			"    return (x * y) // gcd(x, y)",
			"",
			"def gcd_list(numbers):",
			"    return reduce(gcd, numbers)",
			"",
			"def lcm_list(numbers):",
			"    return reduce(lcm, numbers)",
		],
		"description": "最大公約数"
	},
	"lcm": {
		"scope": "python",
		"prefix": "lcm",
		"body": [
			"from functools import reduce",
			"",
			"def gcd(a, b):",
			"    while b:",
			"        a, b = b, a % b",
			"    return a",
			"",
			"def lcm(x, y):",
			"    return (x * y) // gcd(x, y)",
			"",
			"def gcd_list(numbers):",
			"    return reduce(gcd, numbers)",
			"",
			"def lcm_list(numbers):",
			"    return reduce(lcm, numbers)",
		],
		"description": "最小公倍数"
	},
	"rep_sqr": {
		"scope": "python",
		"prefix": "rep",
		"body": [
			"def rep_sqr(base, k, mod=10**9+7):",
			"    if k == 0:",
			"        return 1",
			"    elif k % 2 == 0:",
			"        return (rep_sqr(base, k / 2, mod) ** 2) % mod",
			"    else:",
			"        return (rep_sqr(base, k - 1, mod) * base) % mod",
		],
		"description": "繰り返し二乗法"
	},
	"lcm_list_mod": {
		"scope": "python",
		"prefix": "lcm_mod",
		"body": [
			"from collections import defaultdict",
			"",
			"",
			"class LCM_mod:",
			"    # 最小公倍数の計算を行う",
			"    # オーバーフローが発生しないように素因数分解し,",
			"    # 因数の積を逐次余りに置き換えて最小公倍数を導出する.",
			"",
			"    def __init__(self, max_num, p=10**9+7):",
			"        self.max_num = max_num + 1",
			"        self.p = p",
			"        self.prime = [0 for _ in range(self.max_num)]",
			"        self.max_map = defaultdict(int)",
			"        self.sieve()",
			"",
			"    def rep_sqr(self, base, k):",
			"        # 繰り返し二乗法",
			"        if k == 0:",
			"            return 1",
			"        elif k % 2 == 0:",
			"            return (self.rep_sqr(base, k / 2) ** 2) % self.p",
			"        else:",
			"            return (self.rep_sqr(base, k - 1) * base) % self.p",
			"",
			"    def sieve(self):",
			"        # エラトステネスの篩　O(n)",
			"        # nまでに含まれる素数を導出",
			"        self.prime[0], self.prime[1] = 1, 1",
			"        for i in range(2, self.max_num):",
			"            if self.prime[i] == 0:",
			"                for j in range(i * 2, self.max_num, i):",
			"                    if self.prime[j] == 0:",
			"                        self.prime[j] = i",
			"                self.prime[i] = i",
			"",
			"    def lcm_list_mod(self, arr):",
			"        # listのそれぞれの要素について、素因数分解する",
			"        # それぞれの因数について最大であれば更新する",
			"        for i in range(len(arr)):",
			"            num = arr[i]",
			"            d = defaultdict(int)",
			"",
			"            while num > 1:",
			"                fact = self.prime[num]",
			"                d[fact] += 1",
			"                num //= fact",
			"",
			"            for i in d.keys():",
			"                self.max_map[i] = max(self.max_map[i], d[i])",
			"",
			"        ans = 1",
			"        for i in self.max_map.keys():",
			"            ans = (ans * self.rep_sqr(i, self.max_map[i])) % self.p",
			"        return ans",
		],
		"description": "最小公倍数が大きくなった時にmodを取る"
	},
}